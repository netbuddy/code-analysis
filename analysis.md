# 问题分类
影响系统稳定性的问题大致分为4类：程序退出、程序挂起、随机性故障和性能问题。程序退出分为三类，一类是启动失败，程序一运行就退出，另一类是资源耗尽而退出，还有一类是非法地址访问引起的段错误。程序挂起也分为三类，分别是死锁、死循环和系统调用阻塞。随机性故障指的是偶发、无法复现的问题，这也是最难解决的一类问题，大致的原因包括内存管理错误、内存未初始化和野指针。性能问题也是一类比较头疼的问题，需要具备熟悉系统内核的能力水平才能发现瓶颈所在。

![问题分类](img/问题分类.png)

# 验证技术
造成以上问题的原因很多，包括生产环境的噪声、三方软件的缺陷、长时间运行的累积效应等，但根本原因还是在于代码编写不规范、不严谨、不充分，没有经历科学而完整的代码审查过程就直接发布到生产环境，隐患被触发表征为了问题。

代码审查包含了很多维度的技术实现，本文着重论述采用代码分析技术开展系统稳定性验证的流程。

代码分析分为静态分析和动态追踪两种不同的技术。

## 静态分析技术
静态分析（Static Analyse）是指在**不执行代码**的情况下对其进行分析评估的过程，通过扫描代码模式和结构以及分析逻辑关系，查找潜在缺陷代码，最终将报告呈现给开发人员以便修复代码缺陷。静态分析能够以较小的人力成本让开发人员快速投入到质量控制流程中，还能够通过评判规则的解释和示例代码的展示，促进开发人员编写更高质量的代码，一般为代码动态分析和人工审查的前置阶段。

静态分析的缺点同样也比较明显，在分布式并发系统中，部分问题在特定时序、特定压力下才会暴露出来，因此必须将系统运行起来采用
动态跟踪技术进行追查。

## 动态追踪技术
动态追踪（Dynamic Tracing）是指在系统运行之时的在线分析技术，深入进程和线程内部实时观察和跟踪内存堆栈、CPU寄存器、系统调用、函数调用等动态信息，通过人工编写、编译器插入、操作系统自带的探针（Probe）收集、汇总、分析系统运行时状态信息，用于无法复现和不适用于断点调试的运行时问题追查。

动态追踪的主要缺点在于1）运行速率一般会降低数倍；2）动态追踪具有副作用，当采用调试工具诊断系统时，必然会影响和干扰被测系统的运行状态。

# 范围确定
开展代码分析并不意味者一头就扎入代码的狂潮中挣扎起伏，这样很容易导致“只见树木、不见森林”，只考虑局部代码改进而忽视了对系统的整体影响。

由代码构成的系统整体，有其被创造的背景、要实现的目标、演进过程中面临的困难和决策，以及最终所为用户认知的形态。代码分析从系统整体入手，围绕系统的核心业务流程、典型应用场景、关键技术指标，聚焦于关键、重要的应用组件和核心、基础的支撑技术，秉承务实、求真、至善的态度，从成本、效能、风险的角度分阶段、有重点地推进代码分析工作。

1. 绘制全局组件地图
基于组件接收和发送的消息接口绘制组件依赖关系地图，梳理核心业务流程所依托的组件，识别依赖关系多、承担任务重的重要组件，列为先期开展工作的目标。

2. 技术代码分析
业务代码就是指具体项目中设计业务逻辑的代码，表现为计算、赋值、分支、循环等代码形式，即通过**数理逻辑**的方式返回最终结果。而技术代码则是针对计算机的特点，关注如何高效、安全、正确地**调度和使用**从操作系统、中间件层面获取CPU、内存、IO、网络等各类**计算机资源**。

系统稳定性的问题绝大多数都表现为技术代码编写的不规范，例如为了使用多核而引入多线程技术导致死锁、竞态等问题，为了灵活运用内存而采用堆分配机制导致内存泄漏、悬空指针等问题，为了进程间通信而采用共享内存机制导致同步、互斥等问题。

通过关键字匹配、抽象语法树提取等技术识别出关键的技术代码，通过机器和人工双重研判的方式开展代码分析。

3. 

# 建立修复分支
代码版本管理的基本策略是主干（master/trunk）为发布稳定版本，任何开发人员不允许直接提交代码至主干，而应该先建立一个系统稳定性修复分支（fix），代码编译完成、通过单元自测试后提交至该分支，对该分支代码经过代码审查后才能提交至主干。

# 流程设定
选取适合的代码分析工具，设定代码分析的流程，编制用于记录验证过程的表格模板。

## 静态分析
1. 在一台X64架构的Linux系统中创建目录
2. 将待分析的源代码拷贝到该目录中
3. 安装clang、cppcheck、sonarcube分析工具
4. 

## 动态分析

# 验证实施

# 问题管理
redmine 是一个开源的、基于Web的项目管理和缺陷跟踪工具，提供了问题分配跟踪、甘特图、Wiki、项目论坛、SCM(svn、git)集成等功能，在问题流转的各个环节可自定义字段，满足不同项目的需求，为问题的闭环管理提供了专业化的技术手段。

# 问题确认
静态分析软件给出的分析报告中的问题大致可分为4类，第一类是真正的问题隐患，第二类是没有什么实质危害、可以忽略的警告，第三类是经过人工判断、确认该异常分支不会出现的误报，对于第二类警告信息，可以从软件的检查规则中剔除掉。

# 代码完善
对于个别模块出现的特异性问题进行人工修改，对于共性问题和修改处较多的问题，采用重构工具进行批量修改，降低工作量和人工修改出错的可能。

# 回归测试
为了防止代码修改的副作用，避免无意破坏系统的其它功能，维持代码的整体质量，需要在对问题修改验证后再对系统功能进行回归测试。回归测试需要制定完善的策略，在测试的有效性和高效性之间取得平衡，既要选取足够多的业务测试场景覆盖系统的核心功能，又要保证测试活动能够快速完成，让回归测试成为一种常态化的手段。

# 方案固化
调试的经验和知识如果只是停留在个人的脑海里，时间一长，难免淡忘，之后再遇到同样的问题除了感到似曾相识之外，已经忘记了调试的过程和方法，只能沿老路再走一遍，难免费时费力。“我为人人，人人为我”，通过将个人的经验和知识进行书面化、逻辑化、系统化，既可以促进开发人员之间的技术交流、触发灵感，推动新知识的产生，又能够积累组织级的知识财富，通过知识共享达到出现的问题能解决、解决的问题不复现的效果。


valgrind是用于检查程序运行时问题的工具集，由内核（core）以及基于内核的调试插件组成。valgrind的内核在应用程序和CPU运行环境中建立了一个虚拟运行环境，调试插件从虚拟运行环境中获取应用程序的运行状态从而开展调试工作。valgrind提供了5个功能强大的插件，分别是memcheck-检查内存使用的问题，callgrind -监控程序代码的运行时间和调用过程，用于程序性能的分析，cachegrind -检查CPU的cache命中率、丢失率，用于进行代码优化，helgrind -检查多线程程序中出现的竞态条件。valgrind的使用方法会结合之后的实战篇进行讲解。
